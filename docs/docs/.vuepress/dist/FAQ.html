<!DOCTYPE html>
<html lang="en-US">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Frequently Asked Questions | ProximaDB</title>
		<meta name="description" content="An authenticated database" />

		<link rel="preload" href="/assets/css/0.styles.63dd5439.css" as="style" />
		<link rel="preload" href="/assets/js/app.e72122a9.js" as="script" />
		<link rel="preload" href="/assets/js/2.ca605dc8.js" as="script" />
		<link rel="preload" href="/assets/js/7.2bc2d634.js" as="script" />
		<link rel="prefetch" href="/assets/js/10.e5dfd44c.js" />
		<link rel="prefetch" href="/assets/js/11.58fa5a60.js" />
		<link rel="prefetch" href="/assets/js/12.e33a1b6c.js" />
		<link rel="prefetch" href="/assets/js/3.7f833c13.js" />
		<link rel="prefetch" href="/assets/js/4.c8693186.js" />
		<link rel="prefetch" href="/assets/js/5.74568b92.js" />
		<link rel="prefetch" href="/assets/js/6.07728154.js" />
		<link rel="prefetch" href="/assets/js/8.9d27b7d6.js" />
		<link rel="prefetch" href="/assets/js/9.c399e2b0.js" />
		<link rel="stylesheet" href="/assets/css/0.styles.63dd5439.css" />
	</head>
	<body>
		<div id="app" data-server-rendered="true">
			<div class="theme-container">
				<header class="navbar">
					<div class="sidebar-button">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							aria-hidden="true"
							role="img"
							viewBox="0 0 448 512"
							class="icon"
						>
							<path
								fill="currentColor"
								d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"
							></path>
						</svg>
					</div>
					<a href="/" class="home-link router-link-active"
						><!---->
						<span class="site-name">ProximaDB</span></a
					>
					<div class="links">
						<div class="search-box">
							<input aria-label="Search" autocomplete="off" spellcheck="false" value="" />
							<!---->
						</div>
						<!---->
					</div>
				</header>
				<div class="sidebar-mask"></div>
				<aside class="sidebar">
					<!---->
					<ul class="sidebar-links">
						<li><a href="/" class="sidebar-link">Overview</a></li>
						<li><a href="/Architecture.html" class="sidebar-link">How it works</a></li>
						<li><a href="/Getting-started.html" class="sidebar-link">Getting Started</a></li>
						<li><a href="/API.html" class="sidebar-link">Documentation</a></li>
						<li><a href="/Integrations.html" class="sidebar-link">Integrations</a></li>
						<li><a href="/Tutorials.html" class="sidebar-link">Tutorial</a></li>
						<li>
							<a href="/FAQ.html" class="active sidebar-link">Frequently Asked Questions</a>
							<ul class="sidebar-sub-headers">
								<li class="sidebar-sub-header">
									<a
										href="/FAQ.html#what-is-the-genesis-of-proxima-how-did-it-occur-to-you-to-use-ztrie-tree-to-create-an-efficient-data-layer-for-the-blockchain"
										class="sidebar-link"
										>What is the genesis of Proxima? How did it occur to you to use Urkel tree to
										create an efficient data layer for the blockchain?</a
									>
								</li>
								<li class="sidebar-sub-header">
									<a
										href="/FAQ.html#can-you-tell-us-what-ztrie-tree-is-and-how-it-is-used-in-handshake"
										class="sidebar-link"
										>Can you tell us what Urkel tree is and how it is used in Handshake?</a
									>
								</li>
								<li class="sidebar-sub-header">
									<a
										href="/FAQ.html#how-does-proxima-deal-with-different-types-of-data-in-the-smart-contract"
										class="sidebar-link"
										>How does Proxima deal with different types of data in the smart contract?</a
									>
								</li>
								<li class="sidebar-sub-header">
									<a href="/FAQ.html#would-proxima-work-with-dags" class="sidebar-link"
										>Would Proxima work with DAGs?</a
									>
								</li>
								<li class="sidebar-sub-header">
									<a href="/FAQ.html#why-use-a-trie" class="sidebar-link">Why use a trie?</a>
								</li>
								<li class="sidebar-sub-header">
									<a
										href="/FAQ.html#how-are-range-queries-filters-and-other-database-operations-proven-through-the-proximadb"
										class="sidebar-link"
										>How are range queries, filters, and other database operations proven through
										the ProximaDB?</a
									>
								</li>
							</ul>
						</li>
					</ul>
				</aside>
				<main class="page">
					<div class="theme-default-content content__default">
						<h1 id="frequently-asked-questions">
							<a href="#frequently-asked-questions" aria-hidden="true" class="header-anchor">#</a>
							Frequently Asked Questions
						</h1>
						<h2
							id="what-is-the-genesis-of-proxima-how-did-it-occur-to-you-to-use-ztrie-tree-to-create-an-efficient-data-layer-for-the-blockchain"
						>
							<a
								href="#what-is-the-genesis-of-proxima-how-did-it-occur-to-you-to-use-ztrie-tree-to-create-an-efficient-data-layer-for-the-blockchain"
								aria-hidden="true"
								class="header-anchor"
								>#</a
							>
							What is the genesis of Proxima? How did it occur to you to use Urkel tree to create an
							efficient data layer for the blockchain?
						</h2>
						<p>
							Proxima was conceived because of issues with data availability, security, and developer
							integration for blockchains. None of the toolsets at present, are able to provide a
							traditional development experience without compromising on security or performance.
						</p>
						<p>
							Urkel was chosen over other data structures/libraries (like Patricia Merkle Trie) because it
							was built as a database, not on top of another database. This makes it more performant than
							other blockchain systems.
						</p>
						<p>
							We are currently in the process of moving the Urkel DB to a more generalized scope so that
							it can be implemented with arbitrary key lengths, greater flexibility with data structures,
							and standardized error codes.
						</p>
						<h2 id="can-you-tell-us-what-ztrie-tree-is-and-how-it-is-used-in-handshake">
							<a
								href="#can-you-tell-us-what-ztrie-tree-is-and-how-it-is-used-in-handshake"
								aria-hidden="true"
								class="header-anchor"
								>#</a
							>
							Can you tell us what Urkel tree is and how it is used in Handshake?
						</h2>
						<p>
							The Urkel tree is a flat-file Merkle Tree, it looks similar in nature to Sorted String
							Tables, except instead of having the classic B+ tree as an indexing mechanism, it has a
							Merkle Trie. It was developed to provide shorter proofs and higher throughput for
							reads/writes than the traditional implementations.
						</p>
						<p>
							Handshake protocol uses the Urkel database as an authenticated structure to store their
							certificates and domain data for their naming service. This functionality is similar to the
							Google Certificate Transparency database Trillian (https://github.com/google/trillian).
						</p>
						<h2 id="how-does-proxima-deal-with-different-types-of-data-in-the-smart-contract">
							<a
								href="#how-does-proxima-deal-with-different-types-of-data-in-the-smart-contract"
								aria-hidden="true"
								class="header-anchor"
								>#</a
							>
							How does Proxima deal with different types of data in the smart contract?
						</h2>
						<p>
							Proxima handles different data types by including its own set of schema and data type
							support. Values placed into the ProximaDB are cast to bytes but retrieved as JSON. This can
							be further augmented with blockchain-specific deserialization/serialization of data.
						</p>
						<h2 id="would-proxima-work-with-dags">
							<a href="#would-proxima-work-with-dags" aria-hidden="true" class="header-anchor">#</a> Would
							Proxima work with DAGs?
						</h2>
						<p>
							Since Proxima relies on auditing the blockchains themselves, the risk factors for this type
							of integration would be the consensus of the DAG itself. If transactions can be
							cryptographically tied to the DAG, then Proxima can use this relation when it audits the
							data. For standard blockchains, this is easy because each transaction is a part of the
							Merkle Hash of a single block that is mined through signatures or PoW.
						</p>
						<h2 id="why-use-a-trie">
							<a href="#why-use-a-trie" aria-hidden="true" class="header-anchor">#</a> Why use a trie?
						</h2>
						<p>
							Tries are used because they represent a data structure that is sorted and deterministic.
							This means that synchorinzations can occur in a distirbuted fashion (order of updates will
							not matter), and range queries can be done.
						</p>
						<h2
							id="how-are-range-queries-filters-and-other-database-operations-proven-through-the-proximadb"
						>
							<a
								href="#how-are-range-queries-filters-and-other-database-operations-proven-through-the-proximadb"
								aria-hidden="true"
								class="header-anchor"
								>#</a
							>
							How are range queries, filters, and other database operations proven through the ProximaDB?
						</h2>
						<p>
							At this point, the ProximaDB supplies a Proof-of-soundness for all queries (Range queries,
							filters, etc). This proof ensures that all data given is in the database. Further additions
							to the protocol involve including Proofs-of-Completeness, where it can be proven that the
							data given in a query is all of the data that matches a filter or range.
						</p>
						<p>This problem incorporates two subsets:</p>
						<ul>
							<li>
								<p>
									<strong>Range Queries</strong> Ranges can be proven to be complete by looking at the
									ends of a sorted Merkle Trie, and building a partial Merkle Trie from it. This shows
									that there is no element outside of the desired range, and allows the querier to
									prove that every element within the query can build the partial tree. This topic has
									been breached in the Google
									<a
										href="https://github.com/google/trillian"
										target="_blank"
										rel="noopener noreferrer"
										>Sparse Merkle Trie<svg
											xmlns="http://www.w3.org/2000/svg"
											aria-hidden="true"
											x="0px"
											y="0px"
											viewBox="0 0 100 100"
											width="15"
											height="15"
											class="icon outbound"
										>
											<path
												fill="currentColor"
												d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
											></path>
											<polygon
												fill="currentColor"
												points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
											></polygon></svg></a
									>, and
									<a
										href="https://gist.github.com/chris-belcher/eb9abe417d74a7b5f20aabe6bff10de0"
										target="_blank"
										rel="noopener noreferrer"
										>github discussions<svg
											xmlns="http://www.w3.org/2000/svg"
											aria-hidden="true"
											x="0px"
											y="0px"
											viewBox="0 0 100 100"
											width="15"
											height="15"
											class="icon outbound"
										>
											<path
												fill="currentColor"
												d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
											></path>
											<polygon
												fill="currentColor"
												points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
											></polygon></svg></a
									>. In this case, we use a Merkle trie (a deterministically sorted tree) to ensure
									sorting, and we submit range queries to the keys.
								</p>
							</li>
							<li>
								<p>
									<strong>Filter Queries</strong> Filters where multiple requirements can be met, can
									be done by indexing an entity according to multiple constraints, submitting range
									queries to these different indexes and then doing a union or intersection based on
									the results of these queries.
								</p>
							</li>
						</ul>
						<p>
							One difficulty of this approach is the difficulty of combining multiple range queries at the
							same time. There have been several approaches that utilize accumulators and aggregate
							functions to provide
							<a
								href="https://www.cs.purdue.edu/homes/ninghui/papers/accumulator_acns07.pdf"
								target="_blank"
								rel="noopener noreferrer"
								>efficient nonmembership proofs<svg
									xmlns="http://www.w3.org/2000/svg"
									aria-hidden="true"
									x="0px"
									y="0px"
									viewBox="0 0 100 100"
									width="15"
									height="15"
									class="icon outbound"
								>
									<path
										fill="currentColor"
										d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
									></path>
									<polygon
										fill="currentColor"
										points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
									></polygon></svg></a
							>. The naive approach would be to include every element in the ranges with their proofs for
							membership/nonmembership. The proof would include the subset of all the entities that
							matched the requirements, and a set of those that do not. Proofs could be derived by
							checking membership/nonmembership for all filters.
						</p>
						<p>
							A potential alternative would be to encrypt the data via a homomorphic encryption of the
							<a
								href="https://www.math.u-bordeaux.fr/~gcastagn/publi/isit_homo.pdf"
								target="_blank"
								rel="noopener noreferrer"
								>entire entity schema<svg
									xmlns="http://www.w3.org/2000/svg"
									aria-hidden="true"
									x="0px"
									y="0px"
									viewBox="0 0 100 100"
									width="15"
									height="15"
									class="icon outbound"
								>
									<path
										fill="currentColor"
										d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"
									></path>
									<polygon
										fill="currentColor"
										points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"
									></polygon></svg></a
							>, and to perform the boolean operations on the encrypted schema and filter. In cases where
							privacy is necessary, this is a powerful alternative.
						</p>
					</div>
					<footer class="page-edit">
						<!---->
						<div class="last-updated">
							<span class="prefix">Last Updated: </span> <span class="time">6/24/2019, 7:51:52 AM</span>
						</div>
					</footer>
					<div class="page-nav">
						<p class="inner">
							<span class="prev">
								←
								<a href="/Tutorials.html" class="prev">
									Tutorial
								</a></span
							>
							<!---->
						</p>
					</div>
				</main>
			</div>
			<div class="global-ui"></div>
		</div>
		<script src="/assets/js/app.e72122a9.js" defer></script>
		<script src="/assets/js/2.ca605dc8.js" defer></script>
		<script src="/assets/js/7.2bc2d634.js" defer></script>
	</body>
</html>
